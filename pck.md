# パソコン甲子園問題分析

<br/>

## はじめに

- この資料では[パソコン甲子園過去問](http://aoj-pck.vsw.jp/)を実際に解いて問題の分析や解説を行っています。
- ほぼ僕の主観での分析になるので、参考程度にお願いします。
- ネタバレの嵐なので、一から自力で解きたいという人は見ないほうがいいです。解いた後で興味があったら見てください。

<br/>

## 2019年予選

### 問1 - 柴犬の数

**キーワード：算数** 

足し算するだけ

<br/>

感想：足し算するだけ

<br/>

### 問2 - アスキー文字

**キーワード：比較**

範囲チェック。if( 65<= N <= 90 )と書くとバグります。**if( 65 <= N && N <= 90 )** としましょう。これが落とし穴かな？

<br/>

感想：特になし

<br/>

### 問3 - 2の累乗

**キーワード：ループ** 

2<sup>i</sup> ≦ N < 2<sup>i+1</sup> を満たす2<sup>i</sup>を求める問題です。数学的に考えるとlog<sub>2</sub>Nを取りたくなりますが、一番堅実な方法は調べる区間の左端を示す変数を用意して、ループのたびに2倍することで各区間を調べる方法でしょう。この方法はO(logN)の計算量なのでTLEはありえないです。最初に述べたlog<sub>2</sub>Nを取る方法はO(1)で解けますが、少数の誤差が怖いのであまりお勧めできないです。このような問題は**いかに小数計算を行わずに解を求めるか**というのが重要になると思います。

<br/>

感想：数学で一発で解けそうな問題を敢えて地道に計算するっていう発想を大切にしていきたい

<br/>

### 問4 - 集会場

**キーワード：特定のパラメータを全探索**

- **解法1：全探索**

  集会場を建てる地点を仮に決め打った場合、その地点に全員集合するまでにかかる時間は、各村人について集会場までの距離を計算したうえで、その中の最大値を取得することで求まります。この処理に要する計算量はO(N)です。ここで全探索脳になって考えると、**集会場の位置の最適解としてありえるすべての位置について前述の処理を行うことで最適解が必ず求まる**ことがわかります。ここで、最適解を取りうる集会場の位置としてありえる範囲を考えると、**村人の位置としてありえる最も小さい値（0）～最も大きい値（2000）の間**であることが直感的にわかると思います。したがって、0~2000の全ての位置について最初に述べた処理を行うことで最適解が求まります。全体の計算量は**O(N×maxX)** です。Nの最大値は1000で、maxX = 2000であり、このとき**N×maxX = 1000×2000 = 2×10<sup>6</sup>** であるので余裕で制限時間に間に合います。

  <br/>

- **解法2：スマートな解法**

  全員が集会場に集合するまでにかかる時間は各村人についての集会場までの距離の最大値です。ここで、集会場までの距離の最大値を取りうるのは**最も西側にいる村人か最も東側にいる村人のどちらか**であることが直感的にわかります。このことに着目すると、集会場の地点を決め打った際の村人の距離の最大値は全員の村人について調べる必要はなく、**最西端と最東端の村人についてのみ調べればよい**ため、計算量が**O(N + maxX)** に改善されます。

  <br/>

- **解法3：多分最適解法**

  解法2より、集会場の位置を決め打った際の村人からの距離の最大値は、**最西端の村人からの距離と最東端の村人からの距離の大きい方**です。ここで、この値が最も小さくなるような集会場の位置が一意に定まらないかを考えてみると、最適な位置は**両端の村人のちょうど中間の位置**であることが直感的にわかります。このことに気付くと、集会場の位置を全探索せずとも、両端の村人の位置がわかれば最適解を求めることができます。この解法の計算量は**O(N)** です。（ある長さのテープを2つに切るとき、切った後のテープの長さの最大長が最も小さくなるような位置はどこかという問題にして考えるとわかりやすい？）

<br/>

感想：全探索が間に合いそうなら全探索したほうがいいです

<br/>

### 問5 - ねこのあな

**キーワード：シミュレーション、バケット法、スタック** 

シミュレーションをします。操作内容はc<sub>i</sub>の符号によって以下の2つに分けられます。

- **c<sub>i</sub>>0の場合**

  c<sub>i</sub>を穴に突っ込みます。この時、c<sub>i</sub>がすでに穴の中にいるなら誤りです。

- **c<sub>i</sub><0の場合**

  直近で最後に穴に入った猫を外に出します。この時、穴の中に猫がいないか、外に出した猫が-c<sub>i</sub>でなければ誤りです。

上記のシミュレーションを行うためには、穴の状態を管理するデータ構造と、各猫がすでに穴の中いるかを管理するデータ構造の2つが必要になります。  

穴の状態を管理するデータ構造は、十分な大きさの配列とその配列の最後尾の添え字を示す変数（イテレータ）を用意し、猫を追加する場合は、イテレータ変数をインクリメントして最後尾にc<sub>i</sub>を追加し、猫を取り出す場合は、イテレータ変数をデクリメントするという処理を行うことで実現できます。このようなデータ構造は**スタック**と呼ばれ、C++では**std::stack**として標準で備わっています。  

各猫がすでに穴の中にいるかを管理するデータ構造は、**バケット法**により簡単に実現できます。また、C++が使えるなら、**std:set**で代用できます。

<br/>

感想：データ構造の教育的な問題。だけどデータ構造知らなくてもゴリ押せる良問

<br/>

### 問6 - 床

**キーワード：シミュレーション** 

ぱっと見で思いつく解法としては以下の2つが挙げられると思います。

- **法則を見出してO(1)で対応する色を求める式を考える**
- **愚直にタイルの敷き詰めをシミュレーションする**

前者については一発で対応する色を求める式を割り出すのは難しいので、後者のシミュレーションができないか考えます。タイルが広がる方向は**右、上、左、下、右、上、...** と周期的になっており、色についても**赤、黄、青、赤、...** と周期的になっています。また、タイルの増加幅も、**1、2、3、5、8、...** と規則的になっている（フィボナッチ数列）ため、うまく実装すればシミュレーション自体は可能であることがわかります。続いて、このシミュレーションの計算量について考えると、タイル幅が前述のように増加することから、x,yの絶対値が仮に最大の10<sup>6</sup>であったとしても、余裕をもって制限時間内にx,yまで到達可能です。これらのことからシミュレーションが適切な解法であると言えます。

<br/>

感想：やはり一発で解けそうな問題を敢えて地道に計算するっていう発想めちゃくちゃ大事

<br/>

### 問7 - アカベコ20

**キーワード：bit全探索、最大公約数（GCD）、最小公倍数（LCM）、重複除去**

N人の全ての部分集合をbit演算を用いて列挙し、各部分集合についてその集合に含まれる全てのメンバーが同時に出演する周期を考えます。この周期はその部分集合に含まれる全てのメンバーの出演周期の最小公倍数で与えられます。最小公倍数は**LCM (x, y) = x*y / GCD (x, y)** で求められます。ここで、全員同時に出演する周期（最小公倍数）が等しい組み合わせが複数ある場合、それらの組み合わせは、**それらの部分集合の和集合**として1つの組み合わせにまとめられます。例えば、入力例2を例にとると以下のようになります。

- **LCM = 2   →   { 2 }   →   和集合：{ 2 }**
- **LCM = 3   →   { 3 }   →   和集合：{ 3 }**
- **LCM = 6   →   { 6 }, { 2, 3 }, { 3, 6 }, { 2, 3, 6 }   →   和集合：{ 2, 3, 6 }**

（6のみが出演する回や2,3のみが出演する回はあり得ない。6が出演する回には必ず2,3も出演するし、2,3が出演する回には必ず6も出演する。）

上記の性質から、参加するメンバーの組み合わせの数は**各部分集合がとりうる最小公倍数の総数**であると言えます。

さて、上記の最小公倍数の総数というのは、全ての部分集合について最小公倍数を求めて重複なしで個数をカウントしたものとなります。ここで重複なしでカウントする方法としては、基礎的なデータ構造としてバケット法が考えられますが、最小公倍数の値は数値の組み合わせによっては膨大な値になり、巨大なサイズの配列を必要とするため、手段として適しません。この場合は、**std::set**を用いて重複無しで集合を管理する方法が有効です。

計算量としては、**bit全探索のO(N2<sup>N</sup>) + GCDの計算とsetへの追加（対数時間）** となり、TLEが心配になりますが、ギリギリ制限時間に間に合います。

<br/>

感想：制約にbit全探索しろと言われた

<br/>

### 問8 - 矢印

**キーワード：特定のパラメータを全探索、累積和、シミュレーション**

まずはN個の駒を位置（p<sub>i</sub>）でソートしておきます。

得点が最大になるように操作した後の盤面の最終形を考えると、ある駒を境にして左側と右側のグループに分け、**全ての駒を両端に寄せた状態**が最終形になることがわかります。以下に例を示します。2つ目の例のように矢印がバランスした場合でも得点の変動なしで端に寄せられます。

- |〇〇←〇→〇→←〇〇|（初期盤面）⇒　|←〇〇〇〇〇〇→→←|（得点最大）

- |〇〇→〇←〇|（初期盤面）⇒　|〇〇→←〇〇|（得点最大）⇒　|→←〇〇〇〇|（得点最大のまま）

したがって、N個の駒それぞれについてその駒を境としてすべての駒を両端に寄せた時の得点を求め、その中の最大値を取得することで解が求まります。この計算は愚直に実装すると、境となる駒の候補がN個あり、また、ある駒を境としたときの両端寄せの得点はN個の駒それぞれについて計算する必要があるため計算量は**O(N<sup>2</sup>)** となり、制限時間に間に合いません。ここで、

- **L[ i ] := 左からi個の駒を左詰めした時の得点**
- **R[ i ] := 右からi個の駒を右詰めした時の得点**

というパラメータを事前に求めることを考えます。これらのパラメータは**累積和**というテクニックを用いて端から順に計算していくことで**O(N)** で計算できます。これらのパラメータが事前に求まっていると、境となる駒を決め打った際の両端寄せの得点がL[ ]とR[ ]から**O(1)** で求まるので、全体として計算量が**O(N)** に削減され、制限時間内に解が求まります。他にも、初めにすべての駒を左端に寄せ、後ろの駒から順に1つずつ右端に寄せていくというシミュレーションでもO(N)で計算できます。

<br/>

感想：最終形を考えるの大事

<br/>

### 問9 - 天空の城ツルガ

**キーワード：幾何、二分探索**

まず、影の形状は比の計算で簡単に求まります。ただ、座標が小数になるので、以降**誤差を考慮した実装**が求められます。（結局小数にしたかっただけの前処理）

この問題は影が凸多角形であることに注意すると、**指定されたQ個の点に対して、凸多角形の内包判定**をする問題になります。影が一般的な多角形の場合は、ある点に対しての内包判定は**O(N)** の計算量になりますが、凸多角形の場合は**二分探索**を適用することで**対数時間**で判定できます。判定法はいろいろあると思いますが、以下に2つの判定方法を紹介します。

<br/>

- **凸多角形の重心からの角度に基づいて調べる**

  凸多角形の重心を求め、凸多角形の各頂点に対して**重心からの角度**を求めてソートし、調べたい点が存在する区間を二分探索によって求めることで対数時間で判定する方法です。詳細は[ここ](http://www.prefield.com/algorithm/geometry/convex_contains.html)に載っています。境界ケース（凸多角形の任意の点の角度と調べたい点の角度が一致した場合）がめんどくさそうです。計算量は**O(QlogN)** です。

  <br/>

- **x,y座標に基づいて調べる（僕が参考無しで考えた判定法なので実はガバいかも、この問題では通った）** 

  調べたい点に対して、その点を通る垂直な直線を引いてみると、その点が凸多角形に内包されている場合は、必ずその点の上側と下側に1つずつ凸多角形との交点が存在します。つまり、**ある点が内包されているなら、y軸に対して2つの辺にサンドイッチにされている**ということです。したがって、サンドイッチにされる2つの辺が存在するか判定することで内包されているかを調べることができ、この判定を対数時間で行うことが目標になります。しかし、辺を対象として対数時間で調べるというのは難しい（もしかしたらできるかも）ので、逆に**凸多角形の各辺について、その辺がサンドイッチする対象となる点を調べる**ことで判定を行います。対象となる点は、その辺が存在するx座標の区間内にある点を調べればよく、その区間に含まれる点群の両端の点は**Q個の点を事前にx座標についてソート**しておけば**二分探索**で求めることができます。そして、対象となる点それぞれについて、辺の内側にあるかを調べます。この一連の処理を全ての辺について行った後、最終的に**2回とも内側判定（上辺と下辺）された点は凸多角形の内側、一度でも外側判定された点は凸多角形の外側**として内包判定をすることができます。二分探索する際は、少数の誤差を考慮して、EPS分区間を広めにとって調べるといいです。区間を広げると1つの点に対して3,4個の辺が対応する場合がありますが、計算量にはそこまで影響しないです。この判定法の計算量は、Q個の点のソートで**O(QlogQ)** 、各辺についての判定で**O(NlogQ + Q)** となり、合わせて**O((N+Q)logQ)** となります。

<br/>

感想：典型問題だと思います

<br/>

### 問10 - トーナメントの記録

**キーワード：木、深さ優先探索（DFS）、動的計画法（DP）**

「あり得る対戦の順番が何通りあるか」を「**あり得る負けの順番が何通りあるか（最初にだれが負けて、次に誰が負けて、最後に誰が残る）**」 として数えても答えは同じです。入力の(a<sub>i</sub>, b<sub>i</sub>)は「**b<sub>i</sub>はa<sub>i</sub>より先に負ける**」という情報とみなせるので、グラフ上でa<sub>i</sub>からb<sub>i</sub>に辺を張るという処理を全ての対戦情報について行うと、トーナメントの性質上そのグラフは**選手間の負けの順番の優先順位を示す木**となります。この木が示す優先順位に基づいて負けの順番を列挙する方法を考えましょう。ここでは負けの順番を数列とみなし、数列を後ろから埋めていくことを考えます（最後に誰が残るのかから考える）。数列の最後の要素は優勝者であるので間違いなく木の根の選手でしょう。それでは次の要素としてあり得る選手はどのように決めればよいでしょうか。これは**木の根に隣接した頂点のいずれか**になります。理由は少し考えればわかると思いますが、木の根に隣接していない頂点の選手は必ず木の根に隣接しているいずれかの頂点を根とした部分木に含まれる（部分木に含まれる要素はその根よりも先に負けなければならない⇒数列上で先に現れなければならない）ので、先に根に隣接していない頂点の選手を選ぶと優先順位が崩壊してしまうためです。このことから、3つ目以降の要素についても「**既に数列に追加した頂点に隣接する頂点のうち、まだ数列に追加していない頂点の中から任意に1つ選んで次の要素として追加する**」という手順で埋めていくことで負けの順番を列挙することができます。さて、これによって列挙される負けの順番を数え上げることができればそれが解となります。しかし、上記の手順を愚直にシミュレーションすると、計算量は**O(N!)** となり到底制限時間内に間に合いません。そこで以下のようなDPを考えます。

- **DP[ i ] := 頂点iを根とした部分木内での負けの順番の通り数**

遷移はかなり複雑なので[こちらの類題の解説](https://betrue12.hateblo.jp/entry/2020/03/29/001927)を参考にしてください（類題はAtCoderの問題ですが、DPの遷移は全く同じです）。DFSをして葉から埋めていくことで**O(N)** で全て埋めることができます。遷移の際に必要な組み合わせ<sub>n</sub>C<sub>k</sub>は**法が10<sup>6</sup>と素数ではない**ため除法を用いた公式を使うことができず、**パスカルの三角形**から求める必要があります。事前に計算しておきましょう。パスカルの三角形の計算量は**O(N<sup>2</sup>)** です。答えは**DP[ 木の頂点 ]** になります。

<br/>

感想：個人的に2019予選の中で一番難しかった。AtCoderの類題を過去に解いてなかったら即死だった。[TDPC - N](https://atcoder.jp/contests/tdpc/tasks/tdpc_tree)も類題らしい。上級者にとっては典型DPの模様。

<br/>

### 問11 - イワシロの祈り

**キーワード：約数、バケット法**

当然ですが愚直にやると即TLEです。なんとかして計算量を削減できないでしょうか。

まず大事なこととして、繰り返しの文字列長としてあり得る長さは**Nの約数**です。因みにN≦10<sup>5</sup>の範囲でNの約数としてあり得る最大個数は**128**です。また、繰り返しの判定については、調べる文字列長をL（Nの任意の約数）とすると、**( 要素番号%L )が等しい要素の文字が一致しているか**を調べるとよさそうです。そこで以下のようなバケット法を考えます。

- **D[ i ] := Nの約数のリスト**

- **A[ i ]\[ j ]\[ c ] := 文字列長D[ i ]で分割するとき、( 要素番号%D[ i ] ) == jとなる要素についての文字cの個数**
- **B[ i ] := 文字列長D[ i ]で分割するとき、j = 0 ~ D[ i ]-1 についてA[ i ]\[ j ]\[ c ] == N/D[ i ] となるcが存在するjの個数**

上記B[ i ]において、**A[ i ]\[ j ]\[ c ] == N/D[ i ] という状態は、( 要素番号%D [ i ] ) == jとなる要素が全て文字cで一致している**という意味であり、このようなcが全てのjにおいて存在する場合、つまり、**B[ i ] == D[ i ]のとき、全体の文字列が文字列長D [ i ]の繰り返しになっている**と判定できます。

D[  ]は、Nの約数列挙により生成します。また、初期文字列に基づいてA [  ]とB[  ]の初期状態を最初に計算します。

A[  ]の計算については、初期文字列の各要素に対して、A[ i ]\[ j ]\[ c ]の更新を行います。jはD[ i ]と要素番号から、 cは要素から一意に定まるため、各要素について全てのiに対して更新を行います。Nの約数の個数をMとすると、計算量は**O(NM)** です。

B[  ]の計算については、**A[  ]と同時に更新**していきます。A[ i ]\[ j ]\[ c ]の更新の結果、**A[ i ]\[ j ]\[ c ] がN/D[ i ] -1 から N/D[ i ]になった場合にB[ i ]++, A[ i ]\[ j ]\[ c ]がN/D[ i ]からN/D[ i ]-1になった場合にB[ i ]--とする**ことでA[ i ]\[ j ]\[ c ]の更新に合わせて**O(1)** で更新できます。

それではクエリの処理について考えましょう。文字の入れ替えについては、上記と同様にA[  ]とB[  ]を処理していきます。最大繰り返し文字列長は、**B[ i ] == D[ i ]を満たす最大のi**を求め、D[ i ]を出力すればよいです。これらの処理は1クエリ当たり**O(M)** であり、クエリ処理全体の計算量は**O(QM)** です。

初期状態の計算と合わせると全体の計算量は**O((N+Q)M)** です。Mは最大で**128**なので制限時間内に間に合います。

<br/>

感想：特別高度なデータ構造はいらないけど細かいテクニックで計算の高速化が求められる問題。複雑な処理が最後に噛み合ったときは脳汁がしゅごい。

<br/>

### 問12 - ダンジョン3

**キーワード：二重辺連結成分分解、木の直径**

二重辺連結成分においてはその中に含まれる全ての頂点を訪れることができますが、橋については一度通ると元の二重辺連結成分に戻ることはできません。このことから、二重辺連結成分分解を行い、各二重辺連結成分をその中に含まれる全ての頂点の重みの和として新たな1つの頂点とみなし、木の直径を求めることで解が求まります。計算量は**O(N)** です。

<br/>

感想：ライブラリゲー。知識ゲー。連結成分とか間接点とか橋とかの概念を知ってさえいれば多分簡単。

<br/>

## 2018年予選

### 問1 - 摂氏華氏

**キーワード：算数**

問題文の計算式をそのまま計算するだけ。(F - 30) / 2と**括弧を忘れずに**。

<br/>

感想：括弧を忘れずに

<br/>

### 問2 - 赤とんぼ

**キーワード：絶対値**

2つの値の絶対値を求める問題です。if文を使って差が正になるように実装するのもいいですが、絶対値は標準関数である**abs関数**を用いて計算することができるので、せっかくなので活用しましょう。絶対値計算は競プロでは頻出なのでabs関数が使えると便利です。abs関数はC言語では**stdlib.h**をインクルードすることで使用できるようになります。

<br/>

感想：標準関数を使いこなしましょう。実用性のある標準関数はCompetitiveProgramming.mdの3章でリストにしているので確認してみてください。

<br/>

### 問3 - ケーキパーティー

**キーワード：除算、剰余**

ケーキの合計をPとすると、まず、みんなで平等に分ける際の個数は**P/(N+1)** で求まります。

（注1：int型の除算は小数点以下切り捨てなので、上記の計算で平等に分配可能な個数が整数として都合よく求まります）

（注2：Nは友人の数で自分自身が含まれていないので+1します）

また、余りは**P%(N+1)** で求まり、これが1以上の時は追加で1を加算して出力します。

<br/>

感想：int型除算での小数点以下切り捨て or 切り上げは頻出です。一般にA / Bの除算において、切り捨てはそのまま**A / B** 、切り上げは**( A + B - 1 ) / B** として計算します。切り上げの計算は少しトリッキーなので、原理がわからないという人は「競プロ 切り上げ」等でググってみてください。

<br/>

### 問4 - 熱中症対策

**キーワード：算数、貪欲法、全探索**

1000 * i + 500 * j >= Xという条件の下でA * i + B * jが最小となるようなi, jを求める問題です。

- **解法1：コストを安く抑える戦略を考える（貪欲法と呼ばれます）**

  少し考えると2種類のペットボトルの買い方は以下の3パターンに分けられることがわかります。（切り捨て、切り上げ計算を用いるので問3感想を確認してください）

  <br/>

  - 1リットル当たりの価格が1リットルボトルのほうが安い場合（A<2*Bの場合）、必要量の余りが1000未満になるまで1リットルボトルを買い、

    - 余りが1以上かつ500以下で、500ミリリットルボトルの方が安い(A>B)なら500ミリリットルボトルを1本買う

      → **解：X / 1000 * A + B**	( i = X/1000, j = 1)

    - それ以外の場合は1リットルボトルのみで買い切る

      → **解：(X + 999) / 1000 * A**	( i = (X + 999) / 1000, j = 0)

  - 1リットル当たりの価格が500ミリリットルの方が安い場合（A >= 2*Bの場合）、500ミリリットルボトルのみで買い切る

    → **解：(X + 499) / 500 * B**	( i = 0, j = (X + 499) / 500)

  <br/>

  上記の戦略に基づいて条件分岐することで最適解が求まります。

  因みに、上記の戦略をまとめると結局は

  - 500ミリリットルボトルを1本買い、残りを1リットルボトルで買い切る

    → **解：B + (X - 500 + 999) / 1000 * A**

  - 1リットルボトルのみで買い切る

    → **解：(X + 999) / 1000 * A**

  - 500ミリリットルボトルのみで買いきる

    → **解：(X + 499) / 500 * B**

  の3パターンであるため、条件分岐を考えずにこれら3つの解を脳死で計算してその中の最小値を出力するでもOKです。

  <br/>

- **解法2：全探索**

  入力の制約を見ると、Xの最大値が20000であることから、1リットルボトルの購入個数は多くとも20000/1000 = **20個**、500ミリリットルボトルの購入個数は多くとも20000/500 = **40個**です。このことから、1リットルボトルの購入個数と500ミリリットルボトルの購入個数の21×41通り( i = 0～20, j = 0～40)の**組み合わせを全探索**しても制限時間に余裕で間に合うことがわかります。したがって、21×41通りの購入個数の組み合わせを2重for文で全列挙し、各組み合わせについて、水量の合計がX以上ならその組み合わせの合計金額を解の候補として登録し、最後に候補の中の最小値を求めることで最適解が必ず求まります。この解法は購入戦略等を一切考える必要がなく、もはや問題のコンセプトを破壊した裏技のような解法に思えるかもしれませんが、考察ミスの余地がなくプログラムも単純なため、実はこの解法の方が解法1よりも理にかなった解法であると言えます（計算量は多少かさみますが）。ただ、この手の裏をかいた全探索は計算量に気を付ける必要があるため、やや難しいテクニックであると言えます。

<br/>

感想：全探索最強

<br/>

### 問5 - デュードニー数

**キーワード：特定のパラメータを全探索、数学**

愚直な方法として1～mまでの全てのxについて調べる方法がありますが、mの最大値が10<sup>8</sup>で更に各xについて累乗や桁和の計算をする必要があることからこの方法ではTLEしてしまいます。（10<sup>8</sup>はぎりぎり1秒で計算が間に合うラインで、そこに更に細かい計算が加わると1秒では間に合わなくなります）

まず重要な点として、**条件を満たし得るxは必ずある自然数kをn乗した値**となっています。従って、条件を満たし得る**自然数kを全て列挙**し、各kについてn乗してxを求めて調べるというようにしても実質的に条件を満たしうるxの全列挙が可能になります。こうすることによって条件を満たし得るkの範囲が1～m<sup>1/n</sup>になることから探索幅が**(1/n)乗に圧縮**され、制限時間内に計算が間に合うようになります。各kについて調べる際にはpow関数やループによりkをn乗してxを求め、xの桁和yについてy+a == kとなるかを調べればよいです。

また、より効率的な解法として**yを列挙**する方法があります。yはxの10進桁和であり、xが最大でも10<sup>8</sup>であることから**yは最大でも72** (x = 99999999のとき)にしかならず、また、条件を満たし得るxの中ではxとyは1対1で対応するため、yを列挙して各yの値からxを求めて調べることによってより高速に解を求めることができます。

<br/>

感想：各パラメータがどのような値、性質を持つのかを吟味しましょう

<br/>

### 問6 - ボゾソート

**キーワード：計算量削減**

クエリが与えられるたびに毎回全ての要素について昇順に並んでいるかを調べていては計算量が**O(NQ)** となりTLEになるのでなんとかして高速化したいです。まず、昇順での並びは一意に定まるので、**昇順ソート後の数列を昇順数列**と呼ぶこととすると、この問題は**現状の数列と昇順数列との一致を判定**する問題であると言い換えることができます。ここで、**現状の数列で昇順数列と一致している要素の個数**を格納する変数（ **cnt**とする）を考えます。cntが正確に一致要素数をカウントできていれば、現状の数列が昇順数列と一致しているかは、**全ての要素が一致 ⇒ 一致要素数がN** となることから、**if (cnt == N)** の条件式で**O(1)** で調べることができます。また、2要素の入れ替えについては、各要素について**入れ替え前に昇順数列の要素と一致していたならcntを1減らす**、**入れ替え後に昇順数列の要素と一致したならcntを1増やす**というようにして**O(1)** で更新することができます。これによって2要素の入れ替えと昇順数列との一致判定が**O(1)** で処理できるようになったため、1クエリ当たりの計算量が**O(1)** で処理できるようになりました。昇順数列を求めるためのソートの計算量**O(NlogN)** と合わせて全体の計算量は**O(NlogN + Q)** となり制限時間に間に合います。

<br/>

感想：条件を満たす要素をカウントする変数をこねくり回して計算量を落とすのはPCKで頻出？

<br/>

