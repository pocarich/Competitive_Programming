# パソコン甲子園・情報オリンピック（競技プログラミング）ガイドライン

<br/>

## 0. はじめのはじめに

- あんなん真面目にやる気ねぇよって人はそっ閉じして、どうぞ。
- 高専プロコンやETロボコン等で仕事を任されているならそっちを優先しましょう。

<br/>

<br/>

## 1. はじめに

- パソコン甲子園プログラミング部門や情報オリンピックのようなプログラムの問題を解いて順位を競うようなプログラミングコンテストを**競技プログラミング**（競プロ）と言います。

- 以下では対策を行っていくうえで、**AtCoder**と**AOJ**というサービスを活用します。とりあえず両方アカウント作成しておきましょう。

  <br/>

  - [AtCoder](https://atcoder.jp/) （初めての人はログイン後、[Practice](https://atcoder.jp/contests/practice) のA問題を解いて雰囲気をつかんでください）
  - [AOJ](http://judge.u-aizu.ac.jp/onlinejudge/) 
  - [AOJ-PCK（パソコン甲子園過去問）](http://aoj-pck.vsw.jp/) （ブラウザによってはうまく表示されないぽい？）
  - [AOJ/AtCoder-JOI（情報オリンピック過去問）](https://joi.goodbaton.com/) 

  <br/>

- 競プロ、AtCoderに純粋に興味がある人は以下参考

  - [勉強か？趣味か？人生か？─プログラミングコンテストとは](https://www.slideshare.net/iwiwi/wakate-web-14323842)
  - [レッドコーダーが教える、競プロ・AtCoder上達のガイドライン](https://qiita.com/e869120/items/f1c6f98364d1443148b3)
  - [AtCoderに登録したら次にやること～これだけ解けば十分闘える！過去問精選10問～](https://qiita.com/drken/items/fd4e5e3630d0f5859067)
  - [AtCoder（競技プログラミング）の色・ランクと実力評価、問題例](http://chokudai.hatenablog.com/entry/2019/02/11/155904)

<br/>

<br/>

## 2. 参考サイト

　上記サイトに加え、以下

　- [パソコン甲子園 プログラミング部門 予選の傾向と対策](https://www.hamayanhamayan.com/entry/2018/10/01/014322)

<br/>

<br/>

## 3. レベル1（予選突破まではいかなくとも健闘したい人向け）- AtCoderレート：灰、茶相当

### 全般

- オンラインジャッジの提出結果の意味

  - **AC（Accepted）**

    正解！！　次の問題に進みましょう。

  - **CE（Compile Error）**

    コンパイルエラー。文法にミスがないか、提出ページでの言語選択を間違っていないか等確認しましょう。

  - **RE（Runtime Error）**

    実行時エラー。原因は様々あります。よくある原因は配列サイズ不足や0除算などなど。デバッグ機能を活用しつつ原因を探りましょう。

  - **WA（Wrong Answer）**

    純粋に解法が間違っています。解法に穴がなかったか改めて考え直してみましょう。

  - **TLE（Time Limit Exceeded）**

    実行制限時間超過。計算量が多すぎて制限時間内に計算が終了しなかった場合に表示されます。基本的に<span style="color: red; ">**1秒当たりの計算量（専らループ回数）の上限は10<sup>8</sup>回**</span>です。計算量を削減できないか改めて解法を考え直してみましょう。

  - **MLE（Memory Limit Exceeded）**

    メモリ制限超過。膨大なサイズの配列（<span style="color: red; ">**int型で約10<sup>7</sup>以上？**</span>）を宣言したりすると表示される場合があります。無駄に配列サイズを大きくしていないか、配列を再利用できないか等、改めて考え直してみましょう。

<br/>

- C言語

  **配列、多次元配列、if文、for文、多重for文、while文、文字列等**の知識が必要

  また、以下のヘッダファイルの存在も知っておくこと

  - **<stdio.h>** ：入出力関数（printf, scanf, sprintf 等）

  - **<stdlib.h>**：汎用関数（atoi, atof, bsearch, qsort, abs 等）

  - **<string.h>**：文字列操作（strcpy, strcat, strlen, strcmp 等）

  - **<math.h>**：数学関数（M_PI, sin, cos, atan2, pow, sqrt, fmax, fmin 等）

    ※Visual StudioでM_PIを使用する際は、最初に**#define _USE_MATH_DEFINES **と記述

<br/>

- 浮動小数点数型（float型、double型）出力時の小数点以下桁数指定

  実数の出力が要求される問題では、出力時の小数点数以下桁数が指定される場合があり、**デフォルトの出力桁数では精度が足りない**場合があります。そこで以下に出力桁数の指定方法を示します。

  <br/>

  - C言語

    **printfにおいて%とlfの間に" . [小数点以下桁数] "と記述する。**

    例）小数点以下12桁で出力

    ~~~c++
    double a = 12.5;
    printf("%.12lf\n");		//結果：12.500000000000
    ~~~

  <br/>

  - C++

    **cout<<fixed<<setprecision([小数点以下桁数])と記述してから出力する**

    例）小数点以下12桁で出力

    ~~~c++
    double a = 12.5;
    cout << fixed << setprecision(12) << a <<endl;	//結果：12.500000000000
    ~~~

  <br/>

- 必要なアルゴリズム

  **全探索、バケット法、簡単な数学、算数、剰余の周期性**

  <br/>

- Visual Studioの**デバッグ機能**の使い方を覚えましょう。想定した結果が出力されず、ぱっと見でコードのミスがわからない場合はデバッグ機能を活用しましょう。[このサイト](https://itsakura.com/visualstudio-debug)ではデバッグ機能の簡単な使い方を説明しています。また、デバッグ実行時には実行時エラーが発生した場合にポップアップウィンドウの「無視」を選択することでエラー箇所を指摘してくれます（下図参照）。他にも細かい機能が様々あるので、ぜひ調べてみてください。

<br/>

![g0](img/g0.jpg)

<br/>

![g1](img/g1.jpg)

<br/>

- まずは問題をたくさん解いてプログラミング自体になれるところから始めましょう！！

<br/>

#### [AtCoderBeginnersSelection](https://atcoder.jp/contests/abs)をKagami Mochiまで（Card Game for Twoを除く）埋める

- [ここ](https://qiita.com/drken/items/fd4e5e3630d0f5859067)の5章に解説があるので参考に。
- C言語の解答例を本資料8章に記載してあります。
- このレベルではソートが必要な問題はまず出題されないのでCard Game for TwoはスルーでOK

<br/>

#### [AOJ](http://judge.u-aizu.ac.jp/onlinejudge/) のPROBLEM > Course > Introduction to Programming I を解く

- ひたすら解きまくりましょう。
- 公式の解説が無料では存在しない（はず？）ため、わからない場合は周りの人と相談するなり先輩に聞くなりしましょう（僕に聞いてもいいです）。

<br/>

#### [AOJ-PCK（パソコン甲子園過去問）](http://aoj-pck.vsw.jp/) の問3までの問題を解けるようになる

- 該当するもんだをひたすら解きまくりましょう。解説はパソコン甲子園公式サイトにあったりなかったりします。

<br/>

#### [AOJ/AtCoder-JOI（情報オリンピック過去問）](https://joi.goodbaton.com/) の予選問2までの問題を解けるようになる

- 該当する問題をひたすら解きまくりましょう。解説は情報オリンピック公式サイトにあったりなかったりします。

<br/>

#### [AtCoder Problems](https://kenkoooo.com/atcoder/)のABCのタブのA,B問題を解けるようになる

- 最新の問題から順に解きましょう。
- 問題数が多いのでかなり地力が身につきます。
- 少し考えて解法がわからない場合は解説を見ましょう。

<br/>

<br/>

## 4. レベル2（予選ギリギリ突破レベル）- AtCoderレート：茶、緑相当

### 全般

- レベル1の内容も読んでください。

- **最低限の勉強量**で予選突破を狙いたい人向けです。初歩的なアルゴリズムのみを習得します。

- パソコン甲子園や情報オリンピックでは、中盤あたりからアルゴリズムやデータ構造の知識が要求されるようになり、その境目がおおよそ予選突破のボーダーラインとなる傾向があるため、知識不足で予選突破できないということも残念ながらありえます。安定度は保証できません。

- **実装力**（コード量が多く複雑なプログラムを正確に書く力）が問われる問題が出題され始めるため、プログラミング自体に慣れている必要があります。

- C言語

  **関数、構造体**の知識が必要

- 必要なアルゴリズム

  **時間←→秒変換（10000秒は何時間何分何秒？　3時間45分40秒は何秒？）、N進変換（10進数←→16進数などなど）、シミュレーション、再起関数、ソート、最大公約数・最小公倍数（ユークリッドの互除法）**

  ※変換系はパソコン甲子園でよく出るイメージです

<br/>

#### [AtCoderBeginnersSelection](https://atcoder.jp/contests/abs)を全部埋める

- [ここ](https://qiita.com/drken/items/fd4e5e3630d0f5859067)の5章に解説があるので参考に。
- C言語の解答例を本資料8章に記載してあります。
- <span style="color: red; ">**"1秒当たりの計算量（専らループ回数）の上限は10<sup>8</sup>回"**</span>、めちゃくちゃ重要です。このレベルから計算量オーダーを意識する必要がある問題がぼちぼち登場してきます。計算量については[ここ](https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0)がめちゃくちゃ詳しいです**（必読）**。
- このあたりのレベルから**ソート処理**（配列の要素を昇順または降順に並べ替える）が必要になる可能性があるため、必要になったらすぐにコピペできるようにあらかじめプログラムを用意しておきましょう。本資料8章のCard Game for Twoの解答例でC言語でのソートのサンプルプログラムを記載しているので活用してください。

<br/>

#### [AOJ-PCK（パソコン甲子園過去問）](http://aoj-pck.vsw.jp/) の問6までの問題を解けるようになる

- **問5**までは安定して解けるのが理想です。
- **問6が予選突破のボーダーライン**となる傾向が強いです。難問ぞろいですが頑張りましょう。
- 中には知識不足で解けない問題がある可能性もあるので、そういった問題は潔くあきらめるか別途勉強しましょう。

<br/>

#### [AOJ/AtCoder-JOI（情報オリンピック過去問）](https://joi.goodbaton.com/) の予選問4までかつ難易度6以下の問題を解けるようになる

- **難易度5**までは安定して解けるのが理想です。
- 中には知識不足で解けない問題がある可能性もあるので、そういった問題は潔くあきらめるか別途勉強しましょう。

<br/>

#### [AtCoder Problems](https://kenkoooo.com/atcoder/)のABCのタブのC問題を解けるようになる

- 最新の問題から順に解きましょう。
- 少し考えて解法がわからない場合は解説を見ましょう。
- 上記のAOJ、JOI以上に知識不足で解けない問題がある可能性があるので、そういった問題は潔くあきらめるか別途頑張って勉強しましょう。

<br/>

<br/>

## 5. レベル3（予選突破安定、予選中盤の問題を解けるレベル）- AtCoderレート：緑、水相当

### 全般

- レベル2までの内容も読んでください。**計算量については特に**。
- **ここから必要な勉強量が一気に増えます**。
- **C++**がほぼ必須となります。C++では競プロで頻出のアルゴリズムやデータ構造が**標準ライブラリ（STL）**として備わっているので、使いこなせると便利です。意地でもCで解く場合はすべて自前でライブラリを作成する必要があります（もはや修行僧）。
- C++の学習方法は多数ありますが、[AtCoderの教材](https://atcoder.jp/contests/APG4b)が特に効率的だと思います。競プロではクラスやテンプレートといった高度な機能の実装は必要とされない（STLを使いこなせればよい）ため、そういった機能を除けば学習の手間はそこまで多くないと思います。

<br/>

- 必要なC++ヘッダファイル（とりあえずインクルードしておくこと）

  **\<iostream>, \<sstream>, \<iomanip>, \<cstdio>, \<cstdlib>, \<cstring>, \<cmath>, \<algorithm>, \<numeric>, \<functional>, \<utility>, \<tuple>, \<vector>, \<string>, \<list>, \<set>, \<unordered_set>, \<map>, \<unordered_map>, \<queue>, \<deque>, \<stack>, \<iterator>, \<bitset>, \<complex>, \<limits>, \<random>**

  場合によっては上記以外にも必要になる可能性があるため、その時は適宜新しく追加してください。

<br/>

- 必要なアルゴリズム（競プロ界隈で一般的にこのレベルで必要とされるものを列挙しています。パソコン甲子園と情報オリンピックでは不要なものも一部あります。）

  **bit演算、bit全探索、深さ優先探索（DFS）、幅優先探索（BFS）、最短経路（ベルマンフォード法、ダイクストラ法、ワーシャルフロイド法）、最小全域木（クラスカル法、プリム法）、累積和、imos法、尺取り法、二分探索、三分探索、素数判定、素数列挙（エラトステネスの篩）、素因数分解、約数列挙、順列列挙、modの性質（四則演算、逆元）、一部高校数学（場合の数、確率、期待値、幾何等）、貪欲法、動的計画法（DP）**

  <br/>
  ※C++STL

  **std::lower_bound（二分探索）、std::binary_search（二分探索）、std::sort（ソート）、std::reverse（逆順並び替え）、std::next_permutation（順列列挙）、std::swap（値入れ替え）、std::unique（重複要素の削除の際に使用）**

  <br/>

- 必要なデータ構造

  **比較可能構造体（比較演算子オーバーロード or 比較関数）、連結リスト、平衡二分探索木、連想配列、キュー（待ち行列）、両端キュー、スタック、優先度付きキュー、Union-Find（素集合データ構造）**

  <br/>

  構造体に一部比較演算子のオーバーロードや比較関数の実装をすると、構造体配列をSTLで操作することができて便利です（単純な比較でよければ後述のstd::pairやstd::tupleで代用できます）。比較ルールを自由に定義できるというのは重要な知見です。

  <br/>

  ※C++STL

  **std::pair（2つの値をペアで管理、不等号比較は第一要素、第二要素の順）、std::tuple（複数の値をまとめて管理、不等号比較は第一要素、第二要素、第三要素、…の順）、std::vector（可変長配列）、std::string（文字列）、std::list（連結リスト）、std::set（平衡二分探索木（重複なし））、std::multiset（平衡二分探索木（重複あり））、std::map（連想配列）、std::queue（キュー）、std::deque（両端キュー）、std::stack（スタック）、std::priority_queue（優先度付きキュー）**<br/>

- 整数型（int型）の落とし穴

  　int型の記憶容量は**32ビット**であり、数値にして**約±2×10<sup>9</sup>**までの値を記憶することができます。しかし、競プロでは32ビットを超える数値の計算が必要となる問題が度々出題されます。そのような問題ではint型で計算すると**オーバーフロー**が発生し、正しい計算結果が得られません。

  　そこで登場するのが**long long 型**です。long long 型の記憶容量は**64ビット**（環境によってはそれ以上？）であり、数値にして**約±9×10<sup>18</sup>**までの値を記録することができます。また、64ビットを超える計算が必要な場合は**多倍長整数**という最終手段を用いることになりますが、そこまでの計算が要求される問題はまず出題されないと考えていいです（少なからずパソコン甲子園と情報オリンピックにおいては）。

  <br/>

  ※long long 型のあれこれ

  - long long 型では**リテラルやフォーマット指定子の記述がint型とは異なります**。
    - **リテラル**：例）10 → 10LL,	long long a = 3LL;	**（後ろにLLを付ける）**
    - **フォーマット指定子**：%d → %lld     **（エルエルディー）**
  - long long 型は型名が長いため、typedefやusingを用いて**" ll "（エルエル）と短縮**するのが一般的です。

  <br/>

- 浮動小数点数型（float型、double型）の落とし穴

  　浮動小数点数型は実数を記憶する数値型ですが、実数を完全に誤差なく表現するためには無限の精度が必要であるため、完全な精度で数値を記憶することはできず、表現可能な最も近い数に近似されて記憶されます（線は無限の点の集合であるが、物理的に無限の点を表現するのは不可能であるため、表現可能な最も近い点に近似されるというイメージ）。つまり、**記憶しようとした値と実際に記憶される値には超微小の誤差が生じる**可能性があるということです。そしてこの誤差は計算を重ねるごとに蓄積されていくことも考えられます。

  　さて、競プロでは幾何の問題を筆頭として、実数を扱う問題が度々出題されます。そして、問題によっては**実数同士の比較**が必要となる場面のあるでしょう。例えば、**「ある点の座標と直線の式が与えられたとき、与えられた点がその直線状にあるか判定せよ」**という問題が与えられたとしましょう。解法としては点と直線の距離dを公式等から求め、**if ( d == 0.0)**という条件式によって判定する方法が考えられます。しかし、この条件式では**確かにdが0であるはずなのに条件が満たされない**というケースが発生し得ます。その原因は上述のとおり**dを計算する過程で誤差が生じる**可能性があるためです。等価比較（" == "）は内部で発生する超微小な誤差であっても、完全に一致しなければ偽を返します。ではどのように改良すればよいかというと、適当な**許容誤差EPS**を用意して、微小誤差を許容する判定式に変換します。**EPSは内部で発生する微小誤差よりも大きく、かつ、問題で求められる計算の精度よりも小さいスケール**で設定します。EPSを用いると具体的には以下のように変換されます。

  <br/>

  ~~~c++
  /* double型変数aとbの比較 */
  const double EPS = 1e-9;	//10^(-9)という意味、これくらいが適切らしい
  
  if( a == b )　→　if( abs(a-b) < EPS )	//差がEPS未満なら一致とみなす
  
  if( a != b )　→　if( abs(a-b) > EPS )	//差がEPSより大きいなら不一致
      
  if( a < b )	→　if( abs(a-b) > EPS && a < b )	//差がEPSより大きいかも考慮
  			→　if( a+EPS < b )	//上式と実質同じ（推奨）
      
  if( a <= b)	→　if( abs(a-b) < EPS || a < b)	//差がEPSより小さいなら一致
      		→　if( a-EPS < b )	//上式と実質同じ（推奨）
  ~~~

  ようするに**浮動小数点数型では等価比較は当てにならない**ということです。

  <br/>

- C++ではmain関数内の最初の行に**下記プログラム**を記述することで**入出力の高速化**が期待できます（ジャッジ環境による？）。注意点として、下記プログラムを記述するとprintfやscanfの動作が不安定になる場合があるため、**極力cin, coutのみを使用**するようにしましょう。

  ~~~c++
  cin.tie(0), ios::sync_with_stdio(false);
  ~~~

  <br/>

<br/>



